# Story 1.5: Settings et import initial

## Status: Implemented

## Story
**As a** user,
**I want** to modify my settings and import my health history,
**so that** I can personalize the app and recover my past data.

## Acceptance Criteria
1. L'ecran settings (Screen 4) affiche les infos du serveur et du compte
2. La frequence de sync est modifiable (met a jour le PeriodicWorkRequest)
3. Le bouton "Lancer import initial" lit les 30 derniers jours de Health Connect et les envoie a l'API
4. Un indicateur de progression est affiche pendant l'import initial
5. Le bouton "Voir les logs" affiche les 50 derniers evenements de sync (succes, erreur, nombre de records)
6. Le bouton "Deconnecter" supprime les credentials et revient au setup
7. Les logs sont stockes localement dans une Room database ou un fichier texte

## Tasks / Subtasks
- [ ] Creer SettingsScreen composable (AC: #1)
  - [ ] `ui/settings/SettingsScreen.kt` avec layout complet
  - [ ] Section "Serveur" avec URL affichee et bouton Modifier
  - [ ] Section "Compte" avec email affiche et bouton Deconnecter
  - [ ] Section "Frequence de sync" avec radio buttons
  - [ ] Section "Sync initial" avec bouton import
  - [ ] Section "Debug" avec bouton logs
- [ ] Creer SettingsViewModel (AC: #1, #2, #3, #5, #6)
  - [ ] `ui/settings/SettingsViewModel.kt`
  - [ ] State: serverUrl, email, syncFrequency, importProgress, isImporting, logs
  - [ ] Methode updateSyncFrequency(minutes)
  - [ ] Methode startInitialImport()
  - [ ] Methode disconnect()
  - [ ] Methode loadLogs()
- [ ] Implementer le changement de frequence (AC: #2)
  - [ ] Radio buttons : 15 min, 30 min, 1 heure, 2 heures
  - [ ] Appeler SyncScheduler.schedulePeriodic(newInterval) pour mettre a jour
  - [ ] Persister le choix dans AppPreferences.syncFrequencyMinutes
- [ ] Implementer l'import initial (AC: #3, #4)
  - [ ] Lire les 30 derniers jours depuis Health Connect
  - [ ] Utiliser la permission READ_HEALTH_DATA_HISTORY pour acceder a l'historique
  - [ ] Envoyer les donnees a POST /health-sync
  - [ ] Afficher une ProgressBar pendant l'import
  - [ ] Afficher le nombre de jours importes en temps reel
- [ ] Implementer le systeme de logs (AC: #5, #7)
  - [ ] `data/log/SyncLogRepository.kt` pour stocker les logs
  - [ ] `data/log/SyncLogEntry.kt` data class
  - [ ] Stocker dans un fichier texte local (plus leger que Room)
  - [ ] `ui/settings/LogsScreen.kt` pour afficher les 50 derniers logs
- [ ] Implementer la deconnexion (AC: #6)
  - [ ] AppPreferences.clearAll()
  - [ ] SyncScheduler.cancelAll()
  - [ ] Naviguer vers l'ecran Setup
- [ ] Ajouter la route settings et logs au NavGraph
  - [ ] Route "settings" et route "logs" (sous-ecran)
- [ ] Ecrire les tests unitaires
  - [ ] `SettingsViewModelTest.kt` : test disconnect, frequency change, import flow

## Dev Notes

### Settings UI Wireframe (Screen 4)
```
+----------------------------------+
|  [back] PARAMETRES               |
|                                  |
|  Serveur                         |
|  https://momentum.local:3001     |
|  [Modifier]                      |
|                                  |
|  Compte                          |
|  user@example.com                |
|  [Deconnecter]                   |
|                                  |
|  Frequence de sync               |
|  (o) 15 minutes                  |
|  ( ) 30 minutes                  |
|  ( ) 1 heure                     |
|  ( ) 2 heures                    |
|                                  |
|  Sync initial                    |
|  Importer les 30 derniers jours  |
|  [ LANCER IMPORT INITIAL     ]  |
|                                  |
|  Debug                           |
|  [ VOIR LES LOGS             ]  |
+----------------------------------+
```

### SettingsScreen Implementation

**File**: `app/src/main/java/com/momentum/companion/ui/settings/SettingsScreen.kt`

```kotlin
package com.momentum.companion.ui.settings

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    onBack: () -> Unit,
    onDisconnect: () -> Unit,
    onViewLogs: () -> Unit,
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Parametres") },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Retour")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // Server section
            SettingsSection(title = "Serveur") {
                Text(uiState.serverUrl, style = MaterialTheme.typography.bodyMedium)
                TextButton(onClick = { /* Navigate to setup to modify */ }) {
                    Text("Modifier")
                }
            }

            // Account section
            SettingsSection(title = "Compte") {
                Text(uiState.email, style = MaterialTheme.typography.bodyMedium)
                TextButton(
                    onClick = {
                        viewModel.disconnect()
                        onDisconnect()
                    },
                    colors = ButtonDefaults.textButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text("Deconnecter")
                }
            }

            // Sync frequency section
            SettingsSection(title = "Frequence de sync") {
                SyncFrequencySelector(
                    selected = uiState.syncFrequencyMinutes,
                    onSelect = { viewModel.updateSyncFrequency(it) }
                )
            }

            // Initial import section
            SettingsSection(title = "Sync initial") {
                Text(
                    "Importer les 30 derniers jours",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                if (uiState.isImporting) {
                    LinearProgressIndicator(
                        progress = { uiState.importProgress },
                        modifier = Modifier.fillMaxWidth()
                    )
                    Text(
                        "${uiState.importDaysCompleted} / 30 jours importes",
                        style = MaterialTheme.typography.bodySmall
                    )
                } else {
                    Button(
                        onClick = { viewModel.startInitialImport() },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("LANCER IMPORT INITIAL")
                    }
                }
            }

            // Debug section
            SettingsSection(title = "Debug") {
                OutlinedButton(
                    onClick = onViewLogs,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("VOIR LES LOGS")
                }
            }
        }
    }
}
```

### Sync Frequency Options and WorkManager Update

Available frequencies and their mapping:
```kotlin
data class SyncFrequencyOption(
    val label: String,
    val minutes: Int
)

val SYNC_FREQUENCY_OPTIONS = listOf(
    SyncFrequencyOption("15 minutes", 15),
    SyncFrequencyOption("30 minutes", 30),
    SyncFrequencyOption("1 heure", 60),
    SyncFrequencyOption("2 heures", 120),
)
```

When the user changes frequency:
```kotlin
fun updateSyncFrequency(minutes: Int) {
    viewModelScope.launch {
        preferences.syncFrequencyMinutes = minutes
        syncScheduler.schedulePeriodic(minutes) // Uses ExistingPeriodicWorkPolicy.UPDATE
        _uiState.value = _uiState.value.copy(syncFrequencyMinutes = minutes)
    }
}
```

The `SyncScheduler.schedulePeriodic()` uses `ExistingPeriodicWorkPolicy.UPDATE` which replaces the existing periodic work with the new interval without cancelling and re-creating. This is the recommended way to update periodic work.

### Initial Import (30 Days History)

The initial import reads the last 30 days of Health Connect data and sends it all to the API in a single batch. This requires the `READ_HEALTH_DATA_HISTORY` permission (requested in Story 2.2).

**Implementation**:
```kotlin
fun startInitialImport() {
    viewModelScope.launch {
        _uiState.value = _uiState.value.copy(isImporting = true, importProgress = 0f)

        val endDate = LocalDate.now()
        val startDate = endDate.minusDays(30)

        try {
            // 1. Read all 30 days of data from Health Connect
            _uiState.value = _uiState.value.copy(importProgress = 0.1f)

            val steps = healthConnectReader.readSteps(startDate, endDate)
            _uiState.value = _uiState.value.copy(importProgress = 0.3f)

            val calories = healthConnectReader.readActiveCalories(startDate, endDate)
            _uiState.value = _uiState.value.copy(importProgress = 0.5f)

            val exercises = healthConnectReader.readExerciseSessions(startDate, endDate)
            _uiState.value = _uiState.value.copy(importProgress = 0.6f)

            val sleep = healthConnectReader.readSleepSessions(startDate, endDate)
            _uiState.value = _uiState.value.copy(importProgress = 0.7f)

            // 2. Build the sync request
            val dailyMetrics = HealthConnectMapper.buildDailyMetrics(
                steps, calories, exercises, startDate, endDate
            )
            val activities = HealthConnectMapper.mapExerciseSessions(exercises)
            val sleepRecords = HealthConnectMapper.mapSleepSessions(sleep)

            _uiState.value = _uiState.value.copy(
                importProgress = 0.8f,
                importDaysCompleted = dailyMetrics.size
            )

            // 3. Send to API
            val token = preferences.jwtToken ?: throw Exception("Not authenticated")
            val request = HealthSyncRequest(
                deviceName = Build.MODEL,
                syncedAt = Instant.now().toString(),
                dailyMetrics = dailyMetrics,
                activities = activities,
                sleepSessions = sleepRecords
            )

            val response = apiService.postHealthSync("Bearer $token", request)

            // 4. Update last sync timestamp
            preferences.lastSyncTimestamp = System.currentTimeMillis()

            _uiState.value = _uiState.value.copy(
                importProgress = 1.0f,
                isImporting = false
            )

            // 5. Log the import
            syncLogRepository.log(
                SyncLogEntry(
                    timestamp = System.currentTimeMillis(),
                    type = "INITIAL_IMPORT",
                    status = "SUCCESS",
                    message = "Imported ${response.synced.dailyMetrics} days, " +
                        "${response.synced.activities} activities, " +
                        "${response.synced.sleepSessions} sleep sessions"
                )
            )
        } catch (e: Exception) {
            _uiState.value = _uiState.value.copy(
                isImporting = false,
                error = "Erreur d'import: ${e.message}"
            )
            syncLogRepository.log(
                SyncLogEntry(
                    timestamp = System.currentTimeMillis(),
                    type = "INITIAL_IMPORT",
                    status = "ERROR",
                    message = "Import failed: ${e.message}"
                )
            )
        }
    }
}
```

### READ_HEALTH_DATA_HISTORY Permission

This permission allows reading Health Connect data older than 30 days. It is declared in the manifest (Story 2.2) and requested during the permissions flow. Without this permission, `readRecords` and `aggregate` calls for dates older than 30 days will return empty results.

On Android 14+ (API 34), this permission is part of the Health Connect permission model and is requested alongside other health permissions via the same `PermissionController.createRequestPermissionResultContract()`.

### Sync Log Storage

Use a simple file-based approach (lighter than Room for this use case). Logs are stored as JSON lines in a text file.

**SyncLogEntry.kt** (`app/src/main/java/com/momentum/companion/data/log/SyncLogEntry.kt`):
```kotlin
package com.momentum.companion.data.log

import kotlinx.serialization.Serializable

@Serializable
data class SyncLogEntry(
    val timestamp: Long,
    val type: String,       // "PERIODIC_SYNC" | "MANUAL_SYNC" | "INITIAL_IMPORT"
    val status: String,     // "SUCCESS" | "ERROR" | "RETRY"
    val message: String     // Human-readable details
)
```

**SyncLogRepository.kt** (`app/src/main/java/com/momentum/companion/data/log/SyncLogRepository.kt`):
```kotlin
package com.momentum.companion.data.log

import android.content.Context
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SyncLogRepository @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val logFile: File
        get() = File(context.filesDir, "sync_logs.jsonl")

    private val json = Json { ignoreUnknownKeys = true }

    /**
     * Append a log entry to the file.
     */
    fun log(entry: SyncLogEntry) {
        val line = json.encodeToString(entry) + "\n"
        logFile.appendText(line)

        // Keep only the last 200 entries to prevent unbounded growth
        trimLogs(maxEntries = 200)
    }

    /**
     * Read the last N log entries (most recent first).
     */
    fun getRecentLogs(count: Int = 50): List<SyncLogEntry> {
        if (!logFile.exists()) return emptyList()
        return logFile.readLines()
            .filter { it.isNotBlank() }
            .mapNotNull { line ->
                try { json.decodeFromString<SyncLogEntry>(line) }
                catch (e: Exception) { null }
            }
            .takeLast(count)
            .reversed()
    }

    /**
     * Clear all logs.
     */
    fun clearLogs() {
        if (logFile.exists()) logFile.delete()
    }

    private fun trimLogs(maxEntries: Int) {
        if (!logFile.exists()) return
        val lines = logFile.readLines().filter { it.isNotBlank() }
        if (lines.size > maxEntries) {
            logFile.writeText(lines.takeLast(maxEntries).joinToString("\n") + "\n")
        }
    }
}
```

### Logs Screen

**File**: `app/src/main/java/com/momentum/companion/ui/settings/LogsScreen.kt`

```kotlin
package com.momentum.companion.ui.settings

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.momentum.companion.data.log.SyncLogEntry
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LogsScreen(
    onBack: () -> Unit,
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val logs by viewModel.logs.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Logs de synchronisation") },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Retour")
                    }
                }
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(8.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            items(logs) { entry ->
                LogEntryItem(entry = entry)
            }
        }
    }
}

@Composable
private fun LogEntryItem(entry: SyncLogEntry) {
    val dateFormat = SimpleDateFormat("dd/MM HH:mm", Locale.getDefault())
    val statusColor = when (entry.status) {
        "SUCCESS" -> MaterialTheme.colorScheme.primary
        "ERROR" -> MaterialTheme.colorScheme.error
        else -> MaterialTheme.colorScheme.onSurfaceVariant
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(modifier = Modifier.padding(8.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = entry.type,
                    style = MaterialTheme.typography.labelSmall
                )
                Text(
                    text = dateFormat.format(Date(entry.timestamp)),
                    style = MaterialTheme.typography.labelSmall
                )
            }
            Text(
                text = entry.status,
                style = MaterialTheme.typography.labelMedium,
                color = statusColor
            )
            Text(
                text = entry.message,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}
```

### Disconnect Flow

The disconnect flow must:
1. Clear all stored credentials and preferences
2. Cancel all scheduled WorkManager tasks
3. Navigate back to the Setup screen

```kotlin
fun disconnect() {
    viewModelScope.launch {
        // 1. Cancel all sync work
        syncScheduler.cancelAll()

        // 2. Clear all preferences (token, credentials, settings)
        preferences.clearAll()

        // 3. Optionally clear logs
        // syncLogRepository.clearLogs()

        // Navigation is handled by the UI layer (onDisconnect callback)
    }
}
```

In the NavGraph, after disconnect navigate to Setup and clear the back stack:
```kotlin
onDisconnect = {
    navController.navigate(Screen.Setup.route) {
        popUpTo(0) { inclusive = true }
    }
}
```

### Hilt Injection for SyncLogRepository

Add to `AppModule.kt`:
```kotlin
@Provides
@Singleton
fun provideSyncLogRepository(@ApplicationContext context: Context): SyncLogRepository {
    return SyncLogRepository(context)
}
```

### Navigation for Settings and Logs

Add to `NavGraph.kt`:
```kotlin
composable(Screen.Settings.route) {
    SettingsScreen(
        onBack = { navController.popBackStack() },
        onDisconnect = {
            navController.navigate(Screen.Setup.route) {
                popUpTo(0) { inclusive = true }
            }
        },
        onViewLogs = { navController.navigate(Screen.Logs.route) }
    )
}
composable(Screen.Logs.route) {
    LogsScreen(
        onBack = { navController.popBackStack() }
    )
}
```

Add `Logs` to the `Screen` sealed class:
```kotlin
sealed class Screen(val route: String) {
    object Setup : Screen("setup")
    object Permissions : Screen("permissions")
    object Dashboard : Screen("dashboard")
    object Settings : Screen("settings")
    object Logs : Screen("logs")
}
```

### Integration with SyncWorker Logging

The SyncWorker (Story 2.3) should also log to SyncLogRepository after each sync attempt. Add logging calls at the end of `doWork()`:

```kotlin
// In SyncWorker.doWork() - after successful sync
syncLogRepository.log(
    SyncLogEntry(
        timestamp = System.currentTimeMillis(),
        type = "PERIODIC_SYNC",
        status = "SUCCESS",
        message = "Synced ${response.synced.dailyMetrics} days, " +
            "${response.synced.activities} activities"
    )
)

// In SyncWorker.doWork() - on error
syncLogRepository.log(
    SyncLogEntry(
        timestamp = System.currentTimeMillis(),
        type = "PERIODIC_SYNC",
        status = if (runAttemptCount < 3) "RETRY" else "ERROR",
        message = "Sync failed: ${e.message}"
    )
)
```

### Important Gotchas
- **WorkManager minimum interval**: Even if the user selects 15 minutes, WorkManager may run the task slightly later depending on device state (Doze, battery saver). This is normal
- **Initial import size**: 30 days of data could be a large payload. The API should handle it gracefully. If the payload is too large, consider splitting into 7-day chunks
- **READ_HEALTH_DATA_HISTORY**: This permission must have been granted during the permissions flow (Story 2.2). If not granted, the import will return empty results for older dates. Check permission status before starting import and prompt the user if needed
- **Log file size**: The JSONL log file is trimmed to 200 entries max. Each entry is roughly 200 bytes, so the file stays under 50KB
- **Disconnect does not delete server-side data**: Only local credentials and work schedules are cleared. The data already synced to Momentum remains intact

### Testing
- Test framework: JUnit 5 + MockK
- Test location: `app/src/test/java/com/momentum/companion/`
- **SettingsViewModelTest.kt**:
  - Test `updateSyncFrequency` updates preferences and calls schedulePeriodic
  - Test `startInitialImport` reads 30 days of data and calls API
  - Test import error handling logs the error
  - Test `disconnect` clears preferences and cancels work
- **SyncLogRepositoryTest.kt**:
  - Test `log` appends entries to file
  - Test `getRecentLogs` returns entries in reverse chronological order
  - Test `trimLogs` keeps only maxEntries
  - Test `clearLogs` deletes the file
  - Test reading from empty/missing file returns empty list

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial creation | James (Dev) |

## Dev Agent Record
### Agent Model Used
[To be filled during implementation]

### Debug Log References
[None]

### Completion Notes
[None]

### File List
[To be populated during implementation]
