# Story 2.3: Sync background et envoi API

## Status: Draft

## Story
**As a** user,
**I want** my health data to be automatically synchronized in the background,
**so that** I don't have to open the app manually for my data to appear in Momentum.

## Acceptance Criteria
1. Un `PeriodicWorkRequest` est enregistre via WorkManager avec l'intervalle configure (defaut 15 min)
2. Le `SyncWorker` lit les donnees Health Connect depuis le dernier sync reussi
3. Les donnees sont envoyees a l'endpoint `POST /api/v1/health-sync`
4. En cas de succes, le timestamp du dernier sync est mis a jour
5. En cas d'erreur reseau, le worker retourne `Result.retry()` (max 3 tentatives avec backoff exponentiel)
6. La frequence de sync est configurable dans les settings (15min, 30min, 1h, 2h)
7. Le sync fonctionne meme si l'app est fermee (WorkManager persiste entre les redemarrages)
8. Les contraintes WorkManager sont configurees : reseau requis, batterie non critique

## Tasks / Subtasks
- [ ] Creer les modeles de requete/reponse API (AC: #3)
  - [ ] `data/api/models/HealthSyncRequest.kt` avec DailyMetric, ActivityRecord, SleepRecord, SleepStage
  - [ ] `data/api/models/HealthSyncResponse.kt` avec SyncStatusResponse
- [ ] Implementer SyncWorker (AC: #1, #2, #3, #4, #5)
  - [ ] `sync/SyncWorker.kt` extends CoroutineWorker
  - [ ] Injection Hilt via `@HiltWorker`
  - [ ] Logique de lecture Health Connect depuis lastSyncTimestamp
  - [ ] Agregation et mapping vers HealthSyncRequest
  - [ ] Envoi a l'API avec gestion de token
  - [ ] Mise a jour du lastSyncTimestamp en cas de succes
  - [ ] Retry logic avec max 3 tentatives
- [ ] Implementer SyncScheduler (AC: #1, #6, #7, #8)
  - [ ] `sync/SyncScheduler.kt` avec schedule/cancel/update methods
  - [ ] PeriodicWorkRequest avec intervalle configurable
  - [ ] Contraintes WorkManager (reseau, batterie)
  - [ ] ExistingPeriodicWorkPolicy.UPDATE pour changement de frequence
- [ ] Integrer le scheduler dans le flux applicatif (AC: #7)
  - [ ] Demarrer le sync periodique apres la configuration initiale
  - [ ] Reprendre automatiquement apres un redemarrage
- [ ] Implementer la gestion de token dans le worker (AC: #3)
  - [ ] Lire le token depuis AppPreferences
  - [ ] Si 401, re-login avec les credentials stockes
  - [ ] Si re-login echoue, retourner Result.failure()
- [ ] Ecrire les tests unitaires
  - [ ] `SyncWorkerTest.kt` : mock Health Connect + API, verifier le flow complet
  - [ ] `SyncSchedulerTest.kt` : verifier les contraintes et l'intervalle

## Dev Notes

### API Payload Format (POST /api/v1/health-sync)

This is the main endpoint the SyncWorker calls. The payload bundles all health data for a date range into a single POST request.

**HealthSyncRequest.kt** (`app/src/main/java/com/momentum/companion/data/api/models/HealthSyncRequest.kt`):
```kotlin
package com.momentum.companion.data.api.models

import kotlinx.serialization.Serializable

@Serializable
data class HealthSyncRequest(
    val deviceName: String,           // e.g. "Galaxy Watch 6" (Build.MODEL)
    val syncedAt: String,             // ISO 8601 timestamp of sync
    val dailyMetrics: List<DailyMetric>,
    val activities: List<ActivityRecord>,
    val sleepSessions: List<SleepRecord>
)

@Serializable
data class DailyMetric(
    val date: String,                 // "YYYY-MM-DD"
    val steps: Int?,                  // Total steps for the day
    val activeCalories: Int?,         // Total active kcal for the day
    val activeMinutes: Int?           // Total active minutes for the day
)

@Serializable
data class ActivityRecord(
    val hcRecordId: String,           // Health Connect UUID for dedup
    val date: String,                 // "YYYY-MM-DD"
    val startTime: String,            // ISO 8601
    val endTime: String,              // ISO 8601
    val activityType: String,         // e.g. "WALKING", "RUNNING", "WEIGHTLIFTING"
    val title: String?,
    val durationMinutes: Double,
    val calories: Double?,
    val distance: Double?,            // meters
    val heartRateAvg: Int?,
    val sourceApp: String?            // e.g. "com.samsung.android.health"
)

@Serializable
data class SleepRecord(
    val date: String,                 // "YYYY-MM-DD" (wake-up date)
    val startTime: String,            // ISO 8601
    val endTime: String,              // ISO 8601
    val durationMinutes: Double,
    val score: Int?,                  // Samsung Health score 0-100 if available
    val stages: List<SleepStage>?     // Sleep stage details (optional)
)

@Serializable
data class SleepStage(
    val stage: String,                // "awake" | "light" | "deep" | "rem" | "sleeping"
    val startTime: String,            // ISO 8601
    val endTime: String               // ISO 8601
)
```

**HealthSyncResponse.kt** (`app/src/main/java/com/momentum/companion/data/api/models/HealthSyncResponse.kt`):
```kotlin
package com.momentum.companion.data.api.models

import kotlinx.serialization.Serializable

@Serializable
data class HealthSyncResponse(
    val synced: SyncedCounts,
    val device: DeviceInfo
)

@Serializable
data class SyncedCounts(
    val dailyMetrics: Int,
    val activities: Int,
    val sleepSessions: Int
)

@Serializable
data class DeviceInfo(
    val id: String,
    val lastSyncAt: String
)

@Serializable
data class SyncStatusResponse(
    val configured: Boolean,
    val lastSync: String?,
    val trackables: TrackablesStatus?
)

@Serializable
data class TrackablesStatus(
    val steps: TrackableInfo?,
    val activeCalories: TrackableInfo?,
    val activeMinutes: TrackableInfo?,
    val sleepScore: TrackableInfo?
)

@Serializable
data class TrackableInfo(
    val id: String,
    val goalValue: Int?
)
```

### SyncWorker Implementation

**File**: `app/src/main/java/com/momentum/companion/sync/SyncWorker.kt`

```kotlin
package com.momentum.companion.sync

import android.content.Context
import android.os.Build
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.momentum.companion.data.api.MomentumApiService
import com.momentum.companion.data.api.models.HealthSyncRequest
import com.momentum.companion.data.healthconnect.HealthConnectMapper
import com.momentum.companion.data.healthconnect.HealthConnectReader
import com.momentum.companion.data.preferences.AppPreferences
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId

@HiltWorker
class SyncWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted params: WorkerParameters,
    private val healthConnectReader: HealthConnectReader,
    private val apiService: MomentumApiService,
    private val preferences: AppPreferences
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        // 1. Check configuration
        if (!preferences.isConfigured) return Result.failure()

        // 2. Ensure valid token (re-login if needed)
        val token = ensureValidToken() ?: return Result.failure()

        // 3. Determine date range
        val lastSync = preferences.lastSyncTimestamp
        val startDate = if (lastSync > 0) {
            Instant.ofEpochMilli(lastSync)
                .atZone(ZoneId.systemDefault())
                .toLocalDate()
        } else {
            LocalDate.now().minusDays(1)
        }
        val endDate = LocalDate.now()

        // 4. Read Health Connect data
        val steps = healthConnectReader.readSteps(startDate, endDate)
        val calories = healthConnectReader.readActiveCalories(startDate, endDate)
        val exercises = healthConnectReader.readExerciseSessions(startDate, endDate)
        val sleep = healthConnectReader.readSleepSessions(startDate, endDate)

        // 5. Build request payload
        val dailyMetrics = HealthConnectMapper.buildDailyMetrics(
            steps, calories, exercises, startDate, endDate
        )
        val activities = HealthConnectMapper.mapExerciseSessions(exercises)
        val sleepRecords = HealthConnectMapper.mapSleepSessions(sleep)

        val request = HealthSyncRequest(
            deviceName = Build.MODEL,
            syncedAt = Instant.now().toString(),
            dailyMetrics = dailyMetrics,
            activities = activities,
            sleepSessions = sleepRecords
        )

        // 6. Send to API
        return try {
            apiService.postHealthSync("Bearer $token", request)
            preferences.lastSyncTimestamp = System.currentTimeMillis()
            Result.success()
        } catch (e: Exception) {
            // Retry up to 3 times with exponential backoff
            if (runAttemptCount < 3) {
                Result.retry()
            } else {
                Result.failure()
            }
        }
    }

    private suspend fun ensureValidToken(): String? {
        val token = preferences.jwtToken
        if (token != null) return token

        // Re-login with stored credentials
        val email = preferences.email ?: return null
        val password = preferences.password ?: return null

        return try {
            val response = apiService.login(
                com.momentum.companion.data.api.models.LoginRequest(email, password)
            )
            preferences.jwtToken = response.token
            response.token
        } catch (e: Exception) {
            null
        }
    }

    companion object {
        const val WORK_NAME = "momentum_health_sync"
    }
}
```

### SyncScheduler Implementation

**File**: `app/src/main/java/com/momentum/companion/sync/SyncScheduler.kt`

```kotlin
package com.momentum.companion.sync

import android.content.Context
import androidx.work.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SyncScheduler @Inject constructor(
    private val context: Context
) {
    private val workManager = WorkManager.getInstance(context)

    /**
     * Schedule periodic sync with the given interval.
     * Uses ExistingPeriodicWorkPolicy.UPDATE so calling this again
     * with a different interval will update the existing schedule.
     */
    fun schedulePeriodic(intervalMinutes: Int = 15) {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()

        val workRequest = PeriodicWorkRequestBuilder<SyncWorker>(
            intervalMinutes.toLong(), TimeUnit.MINUTES
        )
            .setConstraints(constraints)
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                WorkRequest.MIN_BACKOFF_MILLIS,   // 10 seconds
                TimeUnit.MILLISECONDS
            )
            .build()

        workManager.enqueueUniquePeriodicWork(
            SyncWorker.WORK_NAME,
            ExistingPeriodicWorkPolicy.UPDATE,
            workRequest
        )
    }

    /**
     * Trigger an immediate one-time sync (used by "Sync Now" button).
     */
    fun syncNow(): OneTimeWorkRequest {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val workRequest = OneTimeWorkRequestBuilder<SyncWorker>()
            .setConstraints(constraints)
            .build()

        workManager.enqueue(workRequest)
        return workRequest
    }

    /**
     * Cancel all scheduled sync work.
     */
    fun cancelAll() {
        workManager.cancelUniqueWork(SyncWorker.WORK_NAME)
    }

    /**
     * Observe the state of sync work (for UI status display).
     */
    fun observeSyncWork() = workManager.getWorkInfosForUniqueWorkLiveData(SyncWorker.WORK_NAME)
}
```

### WorkManager Setup Requirements

**AndroidManifest.xml** additions:
```xml
<!-- WorkManager initialization (Hilt does this automatically with HiltWorkerFactory) -->
<provider
    android:name="androidx.startup.InitializationProvider"
    android:authorities="${applicationId}.androidx-startup"
    android:exported="false"
    tools:node="merge">
    <meta-data
        android:name="androidx.work.WorkManagerInitializer"
        android:value="androidx.startup"
        tools:node="remove" />
</provider>
```

**Custom WorkManager initialization with Hilt** in `MomentumApp.kt`:
```kotlin
@HiltAndroidApp
class MomentumApp : Application(), Configuration.Provider {

    @Inject
    lateinit var workerFactory: HiltWorkerFactory

    override val workManagerConfiguration: Configuration
        get() = Configuration.Builder()
            .setWorkerFactory(workerFactory)
            .build()
}
```

### Error Handling and Retry Strategy

The SyncWorker uses a 3-tier error handling approach:

1. **Network errors** (no connectivity, timeout): Return `Result.retry()` which uses exponential backoff (10s -> 20s -> 40s). WorkManager constraints ensure the next attempt only runs when network is available.

2. **Auth errors** (401 Unauthorized): Attempt automatic re-login with stored credentials. If re-login fails, return `Result.failure()` (credentials likely changed; user needs to reconfigure).

3. **Server errors** (500, payload validation 400): Return `Result.retry()` up to 3 times, then `Result.failure()`. Log the error for the debug log screen (Story 2.5).

```
Attempt 1 fails → retry after ~10s
Attempt 2 fails → retry after ~20s
Attempt 3 fails → Result.failure() (stop retrying)
```

### Hilt WorkManager Integration

Add to `AppModule.kt`:
```kotlin
@Provides
@Singleton
fun provideSyncScheduler(@ApplicationContext context: Context): SyncScheduler {
    return SyncScheduler(context)
}
```

The `@HiltWorker` annotation on `SyncWorker` + `@AssistedInject` constructor enables Hilt to inject dependencies into the worker. The `HiltWorkerFactory` is automatically provided by the `hilt-work` library.

### Dependency on build.gradle.kts (already in Story 2.1)
```kotlin
implementation("androidx.work:work-runtime-ktx:2.10.0")
implementation("androidx.hilt:hilt-work:1.2.0")
ksp("androidx.hilt:hilt-compiler:1.2.0")
```

### Sync Flow Diagram
```
SyncWorker.doWork()
    |
    ├─ Check preferences.isConfigured
    |   └─ false → Result.failure()
    |
    ├─ ensureValidToken()
    |   ├─ Token exists → use it
    |   └─ No token → re-login with stored email/password
    |       └─ Login fails → Result.failure()
    |
    ├─ Calculate date range (lastSync to now)
    |
    ├─ Read Health Connect
    |   ├─ readSteps(startDate, endDate)
    |   ├─ readActiveCalories(startDate, endDate)
    |   ├─ readExerciseSessions(startDate, endDate)
    |   └─ readSleepSessions(startDate, endDate)
    |
    ├─ Build HealthSyncRequest
    |   ├─ HealthConnectMapper.buildDailyMetrics(...)
    |   ├─ HealthConnectMapper.mapExerciseSessions(...)
    |   └─ HealthConnectMapper.mapSleepSessions(...)
    |
    └─ POST /api/v1/health-sync
        ├─ 200 OK → save lastSyncTimestamp → Result.success()
        ├─ 401 → re-login → retry
        └─ Error → runAttemptCount < 3 ? Result.retry() : Result.failure()
```

### Important Gotchas
- **WorkManager minimum interval**: PeriodicWorkRequest has a minimum interval of 15 minutes on Android. You cannot schedule more frequently
- **Doze mode**: WorkManager respects Doze mode. During deep idle, syncs will be deferred until a maintenance window. This is expected and conserves battery (NFR1)
- **READ_HEALTH_DATA_IN_BACKGROUND**: This permission is needed for the SyncWorker to read Health Connect data when the app is not in the foreground. Without it, reads will fail silently
- **WorkManager persistence**: Work requests survive app kills and device reboots. No need to re-schedule on boot
- **Idempotence**: The API endpoint uses upsert (by date+trackableId for metrics, by hcRecordId for activities), so sending duplicate data is safe

### Testing
- Test framework: JUnit 5 + MockK
- Test location: `app/src/test/java/com/momentum/companion/`
- **SyncWorkerTest.kt**:
  - Mock `HealthConnectReader`, `MomentumApiService`, `AppPreferences`
  - Test happy path: data read -> mapped -> sent -> timestamp updated
  - Test network error triggers retry
  - Test max retries reached returns failure
  - Test unconfigured preferences returns failure immediately
  - Test expired token triggers re-login flow
- **SyncSchedulerTest.kt**:
  - Verify `enqueueUniquePeriodicWork` is called with correct interval
  - Verify constraints include CONNECTED network and battery not low
  - Verify `syncNow` creates a OneTimeWorkRequest
  - Verify `cancelAll` cancels the unique work

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial creation | James (Dev) |

## Dev Agent Record
### Agent Model Used
[To be filled during implementation]

### Debug Log References
[None]

### Completion Notes
[None]

### File List
[To be populated during implementation]
