# Story 1.2: Permissions et lecture Health Connect

## Status: Implemented

## Story
**As a** user,
**I want** to authorize the app to read my health data,
**so that** the app can access my steps, calories, exercise sessions, and sleep data.

## Acceptance Criteria
1. L'ecran de permissions (Screen 2) explique quelles donnees seront lues et pourquoi
2. L'app demande les permissions Health Connect listees en section 7.3
3. Si Health Connect n'est pas installe/disponible, un message explicatif est affiche avec un lien vers le Play Store
4. Le `HealthConnectReader` lit correctement les StepsRecord, ActiveCaloriesBurnedRecord, ExerciseSessionRecord, et SleepSessionRecord
5. Les donnees sont aggregees par jour pour les metriques (steps, calories) via `aggregateGroupByPeriod`
6. Les ExerciseSessionRecord sont lues individuellement avec leurs metadonnees (type, duree, calories, distance)
7. Les SleepSessionRecord incluent les stages si disponibles

## Tasks / Subtasks
- [ ] Creer l'ecran de permissions (AC: #1)
  - [ ] `ui/permissions/PermissionsScreen.kt` avec explication des donnees lues
  - [ ] `ui/permissions/PermissionsViewModel.kt` pour gerer l'etat des permissions
  - [ ] Liste visuelle des permissions demandees (pas, calories, exercice, sommeil)
  - [ ] Texte rassurant : "Les donnees sont envoyees uniquement a votre serveur Momentum self-hosted"
- [ ] Implementer la demande de permissions Health Connect (AC: #2)
  - [ ] Declarer les permissions dans `AndroidManifest.xml`
  - [ ] Utiliser `rememberLauncherForActivityResult` avec `PermissionController.createRequestPermissionResultContract()`
  - [ ] Gerer les resultats (toutes accordees vs partielles)
- [ ] Gerer l'absence de Health Connect (AC: #3)
  - [ ] Verifier la disponibilite avec `HealthConnectClient.getSdkStatus()`
  - [ ] Afficher message et bouton "Installer Health Connect" si SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED
  - [ ] Intent vers Play Store pour `com.google.android.apps.healthdata`
- [ ] Implementer HealthConnectReader (AC: #4, #5, #6, #7)
  - [ ] `data/healthconnect/HealthConnectReader.kt`
  - [ ] Methode `readSteps(start, end)` avec aggregateGroupByPeriod
  - [ ] Methode `readActiveCalories(start, end)` avec aggregateGroupByPeriod
  - [ ] Methode `readExerciseSessions(start, end)` avec readRecords
  - [ ] Methode `readSleepSessions(start, end)` avec readRecords
- [ ] Implementer HealthConnectMapper (AC: #5, #6, #7)
  - [ ] `data/healthconnect/HealthConnectMapper.kt`
  - [ ] Mapper ExerciseSessionRecord vers ActivityRecord DTO
  - [ ] Mapper SleepSessionRecord vers SleepRecord DTO
  - [ ] Calculer active minutes depuis ExerciseSessionRecord durees
- [ ] Ajouter la route permissions dans le NavGraph (AC: #1)
  - [ ] Route `permissions` entre `setup` et `dashboard`
  - [ ] Naviguer vers permissions apres setup complet si pas encore accordees
- [ ] Ecrire les tests unitaires
  - [ ] `HealthConnectReaderTest.kt` : mock HealthConnectClient, verifier les aggregations
  - [ ] `HealthConnectMapperTest.kt` : verifier le mapping des records vers les DTOs

## Dev Notes

### Health Connect SDK Setup

**Dependency** (already in build.gradle.kts from Story 2.1):
```kotlin
implementation("androidx.health.connect:connect-client:1.1.0-alpha10")
```

**AndroidManifest.xml** - permissions and intent filter:
```xml
<!-- Health Connect permissions -->
<uses-permission android:name="android.permission.health.READ_STEPS" />
<uses-permission android:name="android.permission.health.READ_ACTIVE_CALORIES_BURNED" />
<uses-permission android:name="android.permission.health.READ_EXERCISE" />
<uses-permission android:name="android.permission.health.READ_SLEEP" />
<uses-permission android:name="android.permission.health.READ_HEART_RATE" />
<uses-permission android:name="android.permission.health.READ_HEALTH_DATA_IN_BACKGROUND" />
<uses-permission android:name="android.permission.health.READ_HEALTH_DATA_HISTORY" />

<!-- Required intent filter for Health Connect permission rationale -->
<activity
    android:name=".ui.permissions.PermissionsRationaleActivity"
    android:exported="true">
    <intent-filter>
        <action android:name="androidx.health.ACTION_SHOW_PERMISSIONS_RATIONALE" />
    </intent-filter>
</activity>

<!-- Declare Health Connect data types used -->
<queries>
    <package android:name="com.google.android.apps.healthdata" />
</queries>
```

### Permission Request Flow

The Health Connect SDK requires a specific contract-based approach to request permissions:

```kotlin
// In PermissionsScreen.kt
val permissions = setOf(
    HealthPermission.getReadPermission(StepsRecord::class),
    HealthPermission.getReadPermission(ActiveCaloriesBurnedRecord::class),
    HealthPermission.getReadPermission(ExerciseSessionRecord::class),
    HealthPermission.getReadPermission(SleepSessionRecord::class),
    HealthPermission.getReadPermission(HeartRateRecord::class),
)

// Create permission launcher
val permissionLauncher = rememberLauncherForActivityResult(
    contract = PermissionController.createRequestPermissionResultContract()
) { grantedPermissions ->
    // Handle result - check if all required permissions were granted
    val allGranted = permissions.all { it in grantedPermissions }
    viewModel.onPermissionsResult(allGranted, grantedPermissions)
}

// Trigger permission request
permissionLauncher.launch(permissions)
```

### Checking Health Connect Availability

```kotlin
// In PermissionsViewModel.kt
fun checkHealthConnectAvailability(context: Context) {
    val status = HealthConnectClient.getSdkStatus(context)
    when (status) {
        HealthConnectClient.SDK_AVAILABLE -> {
            // Ready to use
            _uiState.value = UiState.Ready
        }
        HealthConnectClient.SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED -> {
            // Health Connect needs update or install
            _uiState.value = UiState.NeedsInstall
        }
        HealthConnectClient.SDK_UNAVAILABLE -> {
            // Device doesn't support Health Connect
            _uiState.value = UiState.Unavailable
        }
    }
}

// Intent to install/update Health Connect
val playStoreIntent = Intent(Intent.ACTION_VIEW).apply {
    data = Uri.parse("market://details?id=com.google.android.apps.healthdata")
    setPackage("com.android.vending")
}
```

### HealthConnectReader Implementation

**File**: `app/src/main/java/com/momentum/companion/data/healthconnect/HealthConnectReader.kt`

```kotlin
package com.momentum.companion.data.healthconnect

import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.records.*
import androidx.health.connect.client.request.AggregateGroupByPeriodRequest
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import java.time.LocalDate
import java.time.Period
import java.time.ZoneId
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class HealthConnectReader @Inject constructor(
    private val client: HealthConnectClient
) {

    /**
     * Aggregate steps per day over a date range.
     * Uses aggregateGroupByPeriod with 1-day slicing.
     */
    suspend fun readSteps(start: LocalDate, end: LocalDate): Map<LocalDate, Long> {
        val zone = ZoneId.systemDefault()
        val result = client.aggregateGroupByPeriod(
            AggregateGroupByPeriodRequest(
                metrics = setOf(StepsRecord.COUNT_TOTAL),
                timeRangeFilter = TimeRangeFilter.between(
                    start.atStartOfDay(zone).toInstant(),
                    end.plusDays(1).atStartOfDay(zone).toInstant()
                ),
                timeRangeSlicer = Period.ofDays(1)
            )
        )
        return result.associate { bucket ->
            bucket.startTime.atZone(zone).toLocalDate() to
                (bucket.result[StepsRecord.COUNT_TOTAL] ?: 0L)
        }
    }

    /**
     * Aggregate active calories burned per day.
     * Returns kcal (Double) per day.
     */
    suspend fun readActiveCalories(start: LocalDate, end: LocalDate): Map<LocalDate, Double> {
        val zone = ZoneId.systemDefault()
        val result = client.aggregateGroupByPeriod(
            AggregateGroupByPeriodRequest(
                metrics = setOf(ActiveCaloriesBurnedRecord.ACTIVE_CALORIES_TOTAL),
                timeRangeFilter = TimeRangeFilter.between(
                    start.atStartOfDay(zone).toInstant(),
                    end.plusDays(1).atStartOfDay(zone).toInstant()
                ),
                timeRangeSlicer = Period.ofDays(1)
            )
        )
        return result.associate { bucket ->
            bucket.startTime.atZone(zone).toLocalDate() to
                (bucket.result[ActiveCaloriesBurnedRecord.ACTIVE_CALORIES_TOTAL]
                    ?.inKilocalories ?: 0.0)
        }
    }

    /**
     * Read individual exercise sessions (not aggregated).
     * Returns full ExerciseSessionRecord list with metadata.
     */
    suspend fun readExerciseSessions(
        start: LocalDate,
        end: LocalDate
    ): List<ExerciseSessionRecord> {
        val zone = ZoneId.systemDefault()
        val response = client.readRecords(
            ReadRecordsRequest(
                recordType = ExerciseSessionRecord::class,
                timeRangeFilter = TimeRangeFilter.between(
                    start.atStartOfDay(zone).toInstant(),
                    end.plusDays(1).atStartOfDay(zone).toInstant()
                )
            )
        )
        return response.records
    }

    /**
     * Read sleep sessions with stages.
     * Returns full SleepSessionRecord list.
     */
    suspend fun readSleepSessions(
        start: LocalDate,
        end: LocalDate
    ): List<SleepSessionRecord> {
        val zone = ZoneId.systemDefault()
        val response = client.readRecords(
            ReadRecordsRequest(
                recordType = SleepSessionRecord::class,
                timeRangeFilter = TimeRangeFilter.between(
                    start.atStartOfDay(zone).toInstant(),
                    end.plusDays(1).atStartOfDay(zone).toInstant()
                )
            )
        )
        return response.records
    }
}
```

### Health Connect Data Mapping

The companion reads raw Health Connect records and maps them to the API DTOs defined in `HealthSyncRequest`.

| Source Health Connect | Type HC | Donnee extraite | Trackable Momentum | Unit |
|----------------------|---------|-----------------|-------------------|------|
| `StepsRecord` | Aggregate par jour | Total pas du jour | Pas | pas |
| `ActiveCaloriesBurnedRecord` | Aggregate par jour | Total kcal actives du jour | Calories actives | kcal |
| `ExerciseSessionRecord` | Liste sessions du jour | Somme des durees | Minutes d'activite | min |
| `SleepSessionRecord` | Session de nuit | Duree totale | Dur√©e sommeil | min |
| `ExerciseSessionRecord` | Liste detaillee | Type, duree, calories, distance | HealthActivity (modele dedie) | - |

### HealthConnectMapper Implementation

**File**: `app/src/main/java/com/momentum/companion/data/healthconnect/HealthConnectMapper.kt`

```kotlin
package com.momentum.companion.data.healthconnect

import androidx.health.connect.client.records.ExerciseSessionRecord
import androidx.health.connect.client.records.SleepSessionRecord
import com.momentum.companion.data.api.models.ActivityRecord
import com.momentum.companion.data.api.models.DailyMetric
import com.momentum.companion.data.api.models.SleepRecord
import com.momentum.companion.data.api.models.SleepStage
import java.time.Duration
import java.time.LocalDate
import java.time.ZoneId

object HealthConnectMapper {

    /**
     * Aggregate steps, calories, and exercise durations into DailyMetric list.
     */
    fun buildDailyMetrics(
        steps: Map<LocalDate, Long>,
        calories: Map<LocalDate, Double>,
        exercises: List<ExerciseSessionRecord>,
        startDate: LocalDate,
        endDate: LocalDate
    ): List<DailyMetric> {
        val zone = ZoneId.systemDefault()

        // Calculate active minutes per day from exercise sessions
        val activeMinutesByDay = exercises.groupBy { session ->
            session.startTime.atZone(zone).toLocalDate()
        }.mapValues { (_, sessions) ->
            sessions.sumOf { session ->
                Duration.between(session.startTime, session.endTime).toMinutes()
            }
        }

        val dates = generateSequence(startDate) { it.plusDays(1) }
            .takeWhile { !it.isAfter(endDate) }
            .toList()

        return dates.mapNotNull { date ->
            val daySteps = steps[date]
            val dayCals = calories[date]
            val dayMins = activeMinutesByDay[date]

            // Only include days that have at least one metric
            if (daySteps != null || dayCals != null || dayMins != null) {
                DailyMetric(
                    date = date.toString(),  // "YYYY-MM-DD"
                    steps = daySteps?.toInt(),
                    activeCalories = dayCals?.toInt(),
                    activeMinutes = dayMins?.toInt()
                )
            } else null
        }
    }

    /**
     * Map ExerciseSessionRecord to ActivityRecord DTO.
     */
    fun mapExerciseSessions(sessions: List<ExerciseSessionRecord>): List<ActivityRecord> {
        val zone = ZoneId.systemDefault()
        return sessions.map { session ->
            ActivityRecord(
                hcRecordId = session.metadata.id,
                date = session.startTime.atZone(zone).toLocalDate().toString(),
                startTime = session.startTime.toString(),
                endTime = session.endTime.toString(),
                activityType = exerciseTypeToString(session.exerciseType),
                title = session.title,
                durationMinutes = Duration.between(session.startTime, session.endTime)
                    .toMinutes().toDouble(),
                calories = null,   // Requires separate aggregate query per session
                distance = null,   // Requires separate aggregate query per session
                heartRateAvg = null,
                sourceApp = session.metadata.dataOrigin.packageName
            )
        }
    }

    /**
     * Map SleepSessionRecord to SleepRecord DTO.
     */
    fun mapSleepSessions(sessions: List<SleepSessionRecord>): List<SleepRecord> {
        val zone = ZoneId.systemDefault()
        return sessions.map { session ->
            val duration = Duration.between(session.startTime, session.endTime)
            SleepRecord(
                date = session.endTime.atZone(zone).toLocalDate().toString(), // date du reveil
                startTime = session.startTime.toString(),
                endTime = session.endTime.toString(),
                durationMinutes = duration.toMinutes().toDouble(),
                score = null, // Samsung Health score not exposed via Health Connect
                stages = session.stages.map { stage ->
                    SleepStage(
                        stage = mapSleepStageType(stage.stage),
                        startTime = stage.startTime.toString(),
                        endTime = stage.endTime.toString()
                    )
                }.ifEmpty { null }
            )
        }
    }

    private fun exerciseTypeToString(type: Int): String {
        return when (type) {
            ExerciseSessionRecord.EXERCISE_TYPE_WALKING -> "WALKING"
            ExerciseSessionRecord.EXERCISE_TYPE_RUNNING -> "RUNNING"
            ExerciseSessionRecord.EXERCISE_TYPE_BIKING -> "BIKING"
            ExerciseSessionRecord.EXERCISE_TYPE_SWIMMING_OPEN_WATER -> "SWIMMING"
            ExerciseSessionRecord.EXERCISE_TYPE_WEIGHTLIFTING -> "WEIGHTLIFTING"
            ExerciseSessionRecord.EXERCISE_TYPE_YOGA -> "YOGA"
            ExerciseSessionRecord.EXERCISE_TYPE_HIKING -> "HIKING"
            ExerciseSessionRecord.EXERCISE_TYPE_ELLIPTICAL -> "ELLIPTICAL"
            ExerciseSessionRecord.EXERCISE_TYPE_STAIR_CLIMBING -> "STAIR_CLIMBING"
            else -> "OTHER_WORKOUT"
        }
    }

    private fun mapSleepStageType(stage: Int): String {
        return when (stage) {
            SleepSessionRecord.STAGE_TYPE_AWAKE -> "awake"
            SleepSessionRecord.STAGE_TYPE_LIGHT -> "light"
            SleepSessionRecord.STAGE_TYPE_DEEP -> "deep"
            SleepSessionRecord.STAGE_TYPE_REM -> "rem"
            SleepSessionRecord.STAGE_TYPE_SLEEPING -> "sleeping"
            else -> "sleeping"
        }
    }
}
```

### Hilt Injection for HealthConnectClient

Add to `AppModule.kt`:
```kotlin
@Provides
@Singleton
fun provideHealthConnectClient(@ApplicationContext context: Context): HealthConnectClient {
    return HealthConnectClient.getOrCreate(context)
}

@Provides
@Singleton
fun provideHealthConnectReader(client: HealthConnectClient): HealthConnectReader {
    return HealthConnectReader(client)
}
```

### Screen 2 UI Wireframe
```
+----------------------------------+
|  PERMISSIONS SANTE               |
|                                  |
|  Momentum Companion a besoin     |
|  d'acceder a vos donnees de      |
|  sante pour synchroniser :       |
|                                  |
|  [check] Pas                     |
|  [check] Calories actives        |
|  [check] Sessions d'exercice     |
|  [check] Sommeil                 |
|                                  |
|  Les donnees sont envoyees       |
|  uniquement a votre serveur      |
|  Momentum self-hosted.           |
|                                  |
|  [ AUTORISER L'ACCES SANTE   ]  |
+----------------------------------+
```

### Navigation Integration

After setup (Story 2.1), navigate to permissions screen before dashboard:
```kotlin
// In NavGraph.kt - add route between setup and dashboard
composable(Screen.Permissions.route) {
    PermissionsScreen(
        onPermissionsGranted = { navController.navigate(Screen.Dashboard.route) },
        onSkip = { navController.navigate(Screen.Dashboard.route) }
    )
}
```

### Important Gotchas
- **Android 14+ (API 34)**: Health Connect is built into the platform, but the provider app (`com.google.android.apps.healthdata`) may still need to be updated
- **Background reading**: The permission `READ_HEALTH_DATA_IN_BACKGROUND` is restricted. It requires the app to have foreground service or WorkManager. For the SyncWorker (Story 2.3), this permission is essential
- **READ_HEALTH_DATA_HISTORY**: This is a separate permission for reading data older than 30 days. It is needed for the initial import (Story 2.5). Request it alongside the other permissions
- **Time zones**: Always use `ZoneId.systemDefault()` when converting between Instant and LocalDate. Health Connect stores data in UTC but the user thinks in local time
- **Samsung Health sync delay**: Samsung Health may take 5-15 minutes to push data to Health Connect after collection. This is normal and expected

### Testing
- Test framework: JUnit 5 + MockK
- Test location: `app/src/test/java/com/momentum/companion/`
- **HealthConnectReaderTest.kt**:
  - Mock `HealthConnectClient` using MockK
  - Verify `aggregateGroupByPeriod` is called with correct parameters
  - Test that steps/calories results are correctly mapped to `Map<LocalDate, Long/Double>`
- **HealthConnectMapperTest.kt**:
  - Test `buildDailyMetrics` with various combinations of data
  - Test `mapExerciseSessions` correctly maps exercise types
  - Test `mapSleepSessions` correctly maps sleep stages
  - Test edge case: empty data returns empty lists
- **PermissionsViewModelTest.kt**:
  - Test SDK availability check for all three states
  - Test permission result handling (all granted vs partial)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial creation | James (Dev) |

## Dev Agent Record
### Agent Model Used
[To be filled during implementation]

### Debug Log References
[None]

### Completion Notes
[None]

### File List
[To be populated during implementation]
